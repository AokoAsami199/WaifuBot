// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id)
VALUES ($1)
`

func (q *Queries) CreateUser(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.createUserStmt, createUser, id)
	return err
}

const getChar = `-- name: GetChar :one
SELECT id, user_id, image, name
FROM characters
WHERE id = $1
    AND characters.user_id = $2
LIMIT 1
`

type GetCharParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetChar(ctx context.Context, arg GetCharParams) (Character, error) {
	row := q.queryRow(ctx, q.getCharStmt, getChar, arg.ID, arg.UserID)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Image,
		&i.Name,
	)
	return i, err
}

const getDate = `-- name: GetDate :one
SELECT users.date
FROM users
WHERE users.id = $1
`

func (q *Queries) GetDate(ctx context.Context, id int64) (time.Time, error) {
	row := q.queryRow(ctx, q.getDateStmt, getDate, id)
	var date time.Time
	err := row.Scan(&date)
	return date, err
}

const getUser = `-- name: GetUser :one
SELECT id, quote, date, favorite
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Quote,
		&i.Date,
		&i.Favorite,
	)
	return i, err
}

const getUserCharsIDs = `-- name: GetUserCharsIDs :many
SELECT id
FROM characters
WHERE characters.user_id = $1
`

func (q *Queries) GetUserCharsIDs(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getUserCharsIDsStmt, getUserCharsIDs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserList = `-- name: GetUserList :many
SELECT id, user_id, image, name
FROM characters
WHERE characters.user_id = $1
`

func (q *Queries) GetUserList(ctx context.Context, userID int64) ([]Character, error) {
	rows, err := q.query(ctx, q.getUserListStmt, getUserList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT characters.image,
    characters.name,
    users.date,
    users.quote,
    (
        SELECT count(id)
        FROM characters
        WHERE characters.user_id = $1
    ) as count
FROM users
    LEFT JOIN characters ON characters.id = users.favorite
WHERE users.id = $1
`

type GetUserProfileRow struct {
	Image sql.NullString `json:"image"`
	Name  sql.NullString `json:"name"`
	Date  time.Time      `json:"date"`
	Quote string         `json:"quote"`
	Count interface{}    `json:"count"`
}

func (q *Queries) GetUserProfile(ctx context.Context, userID int64) (GetUserProfileRow, error) {
	row := q.queryRow(ctx, q.getUserProfileStmt, getUserProfile, userID)
	var i GetUserProfileRow
	err := row.Scan(
		&i.Image,
		&i.Name,
		&i.Date,
		&i.Quote,
		&i.Count,
	)
	return i, err
}

const giveChar = `-- name: GiveChar :exec
UPDATE characters
SET user_id = $3
WHERE characters.id = $1
    AND characters.user_id = $2
`

type GiveCharParams struct {
	ID       int64 `json:"id"`
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) GiveChar(ctx context.Context, arg GiveCharParams) error {
	_, err := q.exec(ctx, q.giveCharStmt, giveChar, arg.ID, arg.UserID, arg.UserID_2)
	return err
}

const insertChar = `-- name: InsertChar :exec
INSERT INTO characters ("id", "user_id", "image", "name")
VALUES ($2, $1, $3, $4)
`

type InsertCharParams struct {
	UserID int64          `json:"user_id"`
	ID     int64          `json:"id"`
	Image  sql.NullString `json:"image"`
	Name   sql.NullString `json:"name"`
}

func (q *Queries) InsertChar(ctx context.Context, arg InsertCharParams) error {
	_, err := q.exec(ctx, q.insertCharStmt, insertChar,
		arg.UserID,
		arg.ID,
		arg.Image,
		arg.Name,
	)
	return err
}

const setDate = `-- name: SetDate :exec
UPDATE users
SET date = $2
WHERE users.id = $1
`

type SetDateParams struct {
	ID   int64     `json:"id"`
	Date time.Time `json:"date"`
}

func (q *Queries) SetDate(ctx context.Context, arg SetDateParams) error {
	_, err := q.exec(ctx, q.setDateStmt, setDate, arg.ID, arg.Date)
	return err
}

const setFavorite = `-- name: SetFavorite :exec
UPDATE users
SET favorite = $2
WHERE users.id = $1
`

type SetFavoriteParams struct {
	ID       int64         `json:"id"`
	Favorite sql.NullInt64 `json:"favorite"`
}

func (q *Queries) SetFavorite(ctx context.Context, arg SetFavoriteParams) error {
	_, err := q.exec(ctx, q.setFavoriteStmt, setFavorite, arg.ID, arg.Favorite)
	return err
}

const setQuote = `-- name: SetQuote :exec
UPDATE users
SET quote = $2
WHERE users.id = $1
`

type SetQuoteParams struct {
	ID    int64  `json:"id"`
	Quote string `json:"quote"`
}

func (q *Queries) SetQuote(ctx context.Context, arg SetQuoteParams) error {
	_, err := q.exec(ctx, q.setQuoteStmt, setQuote, arg.ID, arg.Quote)
	return err
}
