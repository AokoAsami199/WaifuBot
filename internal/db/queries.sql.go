// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addOneToClaimCount = `-- name: AddOneToClaimCount :exec
INSERT INTO "users" ("id", "claim_count")
VALUES ($1, 1)
ON CONFLICT ("id") DO
UPDATE SET "claim_count" = users.claim_count + 1 WHERE users.id = $1
`

func (q *Queries) AddOneToClaimCount(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.addOneToClaimCountStmt, addOneToClaimCount, id)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users ("id")
VALUES ($1)
`

func (q *Queries) CreateUser(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.createUserStmt, createUser, id)
	return err
}

const deleteChar = `-- name: DeleteChar :exec
DELETE FROM characters
WHERE "id" = $1 AND "user_id" = $2
`

type DeleteCharParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteChar(ctx context.Context, arg DeleteCharParams) error {
	_, err := q.exec(ctx, q.deleteCharStmt, deleteChar, arg.ID, arg.UserID)
	return err
}

const getChar = `-- name: GetChar :one
SELECT id, user_id, image, name FROM characters
WHERE "id" = $1 AND "user_id" = $2
LIMIT 1
`

type GetCharParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetChar(ctx context.Context, arg GetCharParams) (Character, error) {
	row := q.queryRow(ctx, q.getCharStmt, getChar, arg.ID, arg.UserID)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Image,
		&i.Name,
	)
	return i, err
}

const getDate = `-- name: GetDate :one
SELECT "date"
FROM users
WHERE "id" = $1
LIMIT 1
`

func (q *Queries) GetDate(ctx context.Context, id int64) (time.Time, error) {
	row := q.queryRow(ctx, q.getDateStmt, getDate, id)
	var date time.Time
	err := row.Scan(&date)
	return date, err
}

const getUser = `-- name: GetUser :one
SELECT id, quote, date, favorite, claim_count FROM users
WHERE "id" = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Quote,
		&i.Date,
		&i.Favorite,
		&i.ClaimCount,
	)
	return i, err
}

const getUserList = `-- name: GetUserList :many
SELECT id, user_id, image, name FROM Characters WHERE "user_id" = $1
`

func (q *Queries) GetUserList(ctx context.Context, userID int64) ([]Character, error) {
	rows, err := q.query(ctx, q.getUserListStmt, getUserList, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Character
	for rows.Next() {
		var i Character
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProfile = `-- name: GetUserProfile :many
SELECT a.id, a.user_id, a.image, a.name, users.quote, users.date, users.favorite, users.claim_count FROM
(SELECT id, user_id, image, name FROM characters WHERE "user_id" = $1) AS a
INNER JOIN
users ON users.id = a.user_id
`

type GetUserProfileRow struct {
	ID         int64          `json:"id"`
	UserID     int64          `json:"user_id"`
	Image      sql.NullString `json:"image"`
	Name       sql.NullString `json:"name"`
	Quote      string         `json:"quote"`
	Date       time.Time      `json:"date"`
	Favorite   sql.NullInt64  `json:"favorite"`
	ClaimCount int32          `json:"claim_count"`
}

func (q *Queries) GetUserProfile(ctx context.Context, userID int64) ([]GetUserProfileRow, error) {
	rows, err := q.query(ctx, q.getUserProfileStmt, getUserProfile, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserProfileRow
	for rows.Next() {
		var i GetUserProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Image,
			&i.Name,
			&i.Quote,
			&i.Date,
			&i.Favorite,
			&i.ClaimCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const giveChar = `-- name: GiveChar :exec
UPDATE characters
SET "user_id" = $3
WHERE "id" = $1
AND "user_id" = $2
`

type GiveCharParams struct {
	ID       int64 `json:"id"`
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) GiveChar(ctx context.Context, arg GiveCharParams) error {
	_, err := q.exec(ctx, q.giveCharStmt, giveChar, arg.ID, arg.UserID, arg.UserID_2)
	return err
}

const insertChar = `-- name: InsertChar :exec
INSERT INTO characters ("id", "user_id", "image", "name")
VALUES ($2, $1, $3, $4)
`

type InsertCharParams struct {
	UserID int64          `json:"user_id"`
	ID     int64          `json:"id"`
	Image  sql.NullString `json:"image"`
	Name   sql.NullString `json:"name"`
}

func (q *Queries) InsertChar(ctx context.Context, arg InsertCharParams) error {
	_, err := q.exec(ctx, q.insertCharStmt, insertChar,
		arg.UserID,
		arg.ID,
		arg.Image,
		arg.Name,
	)
	return err
}

const setFavorite = `-- name: SetFavorite :exec
INSERT INTO "users" ("id", "favorite")
VALUES ($1, $2)
ON CONFLICT ("id") DO
UPDATE SET "favorite" = $2 WHERE users.id = $1
`

type SetFavoriteParams struct {
	ID       int64         `json:"id"`
	Favorite sql.NullInt64 `json:"favorite"`
}

func (q *Queries) SetFavorite(ctx context.Context, arg SetFavoriteParams) error {
	_, err := q.exec(ctx, q.setFavoriteStmt, setFavorite, arg.ID, arg.Favorite)
	return err
}

const setQuote = `-- name: SetQuote :exec
INSERT INTO users ("id", "quote")
VALUES ($1, $2)
ON CONFLICT ("id") DO
UPDATE SET "quote" = $2 WHERE users.id = $1
`

type SetQuoteParams struct {
	ID    int64  `json:"id"`
	Quote string `json:"quote"`
}

func (q *Queries) SetQuote(ctx context.Context, arg SetQuoteParams) error {
	_, err := q.exec(ctx, q.setQuoteStmt, setQuote, arg.ID, arg.Quote)
	return err
}

const updateUserDate = `-- name: UpdateUserDate :exec
INSERT INTO "users" ("id", "date")
VALUES ($1, $2)
ON CONFLICT ("id") DO
UPDATE SET "date" = $2 WHERE users.id = $1
`

type UpdateUserDateParams struct {
	ID   int64     `json:"id"`
	Date time.Time `json:"date"`
}

func (q *Queries) UpdateUserDate(ctx context.Context, arg UpdateUserDateParams) error {
	_, err := q.exec(ctx, q.updateUserDateStmt, updateUserDate, arg.ID, arg.Date)
	return err
}
